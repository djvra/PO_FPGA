
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module po_fpga(

	//////////// CLOCK //////////
	input 		          		CLOCK_125_p,
	input 		          		CLOCK_50_B5B,
	input 		          		CLOCK_50_B6A,
	input 		          		CLOCK_50_B7A,
	input 		          		CLOCK_50_B8A,

	//////////// LED //////////
	output		     [7:0]		LEDG,
	output		     [9:0]		LEDR,

	//////////// KEY //////////
	input 		          		CPU_RESET_n,
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3

	//////////// Uart to USB //////////
	//input 		          		UART_RX,
	//output		          		UART_TX
);

parameter ROWS = 2;

wire clk, done, reset, go_i;
wire clk_0, clk_1, clk_2, clk_3, clk_80, clk_90, clk_100, clk_110, clk_120;

//assign reset = ~KEY[3];
//assign go_i = ~KEY[2];

wire raw_reset = ~KEY[3];
wire raw_go_i = ~KEY[2];

one_shot_button one_shot_button_reset (
    .clk(clk),
    .button(raw_reset),
    .pulse_out(reset)
);

one_shot_button one_shot_button_go_i (
    .clk(clk),
    .button(raw_go_i),
    .pulse_out(go_i)
);

//assign clk = CLOCK_50_B5B;

my_clock test_clock(
	.refclk(CLOCK_50_B5B),
	.rst(SW[9]),
	.outclk_0(clk_0), // 100
	.locked(LEDR[1])
);

assign clk = clk_0;

/*my_clock test_clock(
	.refclk(CLOCK_50_B5B),
	.rst(SW[9]),
	.outclk_0(clk_0), // 60
	.outclk_1(clk_1), // 65
	.outclk_2(clk_2), // 70
	.outclk_3(clk_3), // 75
	.locked(LEDR[1])
);

reg clk_mux;
always @(*) begin
  //case (SW[9:6])
  case (SW[7:6])
		2'b00: clk_mux = clk_0; 
		2'b01: clk_mux = clk_1;
		2'b10: clk_mux = clk_2; 
		2'b11: clk_mux = clk_3; 
		default: clk_mux = clk_0;
  endcase
end

assign clk = clk_mux;*/



/*always @(posedge clk) begin
	if (~KEY[3]) begin
		go_i <= 1;
	end else begin
		go_i <= 0;
	end
end*/

//assign go_i = ~KEY[3];
//assign LEDG[0] = ~KEY[3];
//assign LEDG[1] = go_i;

/*reg key3_prev; 

always @(posedge clk) begin
	 key3_prev <= KEY[3];
	 if (~KEY[3] && key3_prev) begin
		go_i = ~KEY[3];
    end
end*/

//assign LEDG[7] = done;
assign LEDR[0] = ~done;

reg [3:0] NUMBER_OF_CONES = 1;

wire [31:0] fpga_total_point_count;
wire [6:0] current_state_test;
//assign LEDR[9:3] = current_state_test;
wire [63:0] state_count;

reg [9:0] result_point_i;
reg [3:0] result_point_j;
wire [7:0] result_point_out;

assign LEDR[9:3] = result_point_i[6:0]; // tum adresleri gostermiyor ledler dolu cunku

// mux select
wire int_add_sub_add_sub_sel, int_divider_clken, int_comparator_dataa_i0_sel, int_comparator_dataa_i1_sel,
			int_comparator_datab_i0_sel, int_comparator_datab_i1_sel, int_comparator_datab_i3_sel, i_sel, v_inner_sel,
			rows_mult_datab_sel;

wire [1:0] int_divider_numer_sel, int_divider_denom_sel, rows_mult_dataa_sel, int_mult_dataa_sel, int_mult_datab_sel;
				
wire [2:0] int_comparator_dataa_sel, int_comparator_datab_sel,
				inner_Res_sel;
				
wire [3:0] int_add_sub_dataa_sel, int_add_sub_datab_sel;

// integer_array operations
wire [1:0] input_array_address_a_sel, input_array_address_b_sel;

// load signal for operator registers
wire ld_int_add_sub_res_reg, ld_int_mult_res_reg, ld_int_comparator_aeb_reg;

// clear
wire clear_i, clear_j, clear_inner_Res, clear_outer, clear_point_count, clear_divider_counter;

// load signal for registers
wire ld_rows_minus_one, ld_each_cone_size, ld_each_cone, ld_V_index, ld_temp_V_index, ld_init_temp_V_index, 
		ld_Uinv_index, ld_temp_Uinv_index, ld_Winv_index, ld_temp_Winv_index, ld_init_temp_Winv_index, 
		ld_q_index, ld_s_index, ld_o_index, ld_last_diagonal, ld_prime_diagonals, 
		ld_q_summand, ld_q_hat, ld_q_trans,	ld_inner_Res, ld_v_inner, ld_total_point_count, ld_outer, ld_result_point,
		ld_point_count, ld_i, ld_j, ld_divider_counter, ld_rows_mult_res_reg;

// array operations
wire clear_arrays;

// input_array operations
wire input_array_wren_a, input_array_wren_b;

wire do_parallel_multiplication, clear_parallel_multiplication_results, increment_temp_Winv_index, parallel_multiplication_second_operand_sel,
		int_parallel_add_first_operand_sel, clear_numerators, assign_numerators, numerator_sel, seq_loader_rst, ld_remain_to_inner_Res,
		ld_result_adjuster_to_inner_Res, parallel_res_adj_rst, parallel_res_adj_en, condition1_triggered, condition2_triggered;
		
wire [1:0] q_array_address_sel;
wire ram_module_input_array_rst, ram_module_input_array_en;

// comparator signals
wire int_comparator_aeb, int_comparator_alb, int_comparator_not_alb, inner_Res_and_input_array, j_index_comparator_alb;

control_unit cu (
	.go_i(go_i),
	.reset(reset),
	.clk(clk),
	.done(done),
	
	.ld_int_add_sub_res_reg(ld_int_add_sub_res_reg),
	.ld_int_mult_res_reg(ld_int_mult_res_reg),
	
	.ld_rows_minus_one(ld_rows_minus_one),
	.ld_each_cone_size(ld_each_cone_size),
	.ld_each_cone(ld_each_cone),
	.ld_V_index(ld_V_index),
	.ld_temp_V_index(ld_temp_V_index),
	.ld_init_temp_V_index(ld_init_temp_V_index),
	.ld_Uinv_index(ld_Uinv_index),
	.ld_temp_Uinv_index(ld_temp_Uinv_index),
	.ld_Winv_index(ld_Winv_index),
	.ld_temp_Winv_index(ld_temp_Winv_index),
	.ld_init_temp_Winv_index(ld_init_temp_Winv_index),
	.ld_q_index(ld_q_index),
	.ld_s_index(ld_s_index),
	.ld_o_index(ld_o_index),
	.ld_last_diagonal(ld_last_diagonal),
	.ld_prime_diagonals(ld_prime_diagonals),
	.ld_q_summand(ld_q_summand),
	.ld_q_hat(ld_q_hat),
	.ld_q_trans(ld_q_trans),
	.ld_inner_Res(ld_inner_Res),
	.ld_v_inner(ld_v_inner),
	.ld_int_comparator_aeb_reg(ld_int_comparator_aeb_reg),
	.ld_total_point_count(ld_total_point_count),
	.ld_result_point(ld_result_point),
	.ld_outer(ld_outer),
	.ld_point_count(ld_point_count),
	.ld_i(ld_i),
	.ld_j(ld_j),
	.ld_divider_counter(ld_divider_counter),
	
	.clear_i(clear_i),
	.clear_j(clear_j),
	.clear_divider_counter(clear_divider_counter),
	
	.clear_point_count(clear_point_count),
	.clear_outer(clear_outer),
	.clear_inner_Res(clear_inner_Res),
	.clear_arrays(clear_arrays),
	
	.int_mult_dataa_sel(int_mult_dataa_sel),
	.int_mult_datab_sel(int_mult_datab_sel),
	.int_add_sub_dataa_sel(int_add_sub_dataa_sel),
	.int_add_sub_datab_sel(int_add_sub_datab_sel),
	.int_add_sub_add_sub_sel(int_add_sub_add_sub_sel),
	.int_comparator_dataa_sel(int_comparator_dataa_sel),
	.int_comparator_datab_sel(int_comparator_datab_sel),
	.int_comparator_dataa_i0_sel(int_comparator_dataa_i0_sel),
	.int_comparator_dataa_i1_sel(int_comparator_dataa_i1_sel),
	.int_comparator_datab_i0_sel(int_comparator_datab_i0_sel),
	.int_comparator_datab_i1_sel(int_comparator_datab_i1_sel),
	.int_comparator_datab_i3_sel(int_comparator_datab_i3_sel),
	.int_divider_numer_sel(int_divider_numer_sel),
	.int_divider_denom_sel(int_divider_denom_sel),
	.int_divider_clken(int_divider_clken),
	.inner_Res_sel(inner_Res_sel),
	.i_sel(i_sel),
	.v_inner_sel(v_inner_sel),
	
	.input_array_address_a_sel(input_array_address_a_sel),
	.input_array_address_b_sel(input_array_address_b_sel),
	.input_array_wren_a(input_array_wren_a),
	.input_array_wren_b(input_array_wren_b),
	
	.do_parallel_multiplication(do_parallel_multiplication),
	.clear_parallel_multiplication_results(clear_parallel_multiplication_results),
	.parallel_multiplication_second_operand_sel(parallel_multiplication_second_operand_sel),
	.q_array_address_sel(q_array_address_sel),
	.int_parallel_add_first_operand_sel(int_parallel_add_first_operand_sel),
	//.increment_temp_Winv_index(increment_temp_Winv_index),
	
	.ram_module_input_array_rst(ram_module_input_array_rst),
	.ram_module_input_array_en(ram_module_input_array_en),
	
	.clear_numerators(clear_numerators),
	.assign_numerators(assign_numerators),
	.numerator_sel(numerator_sel),
	.seq_loader_rst(seq_loader_rst),
	.ld_remain_to_inner_Res(ld_remain_to_inner_Res),
	.ld_result_adjuster_to_inner_Res(ld_result_adjuster_to_inner_Res),
	.parallel_res_adj_rst(parallel_res_adj_rst),
	.parallel_res_adj_en(parallel_res_adj_en),
	
	.rows_mult_dataa_sel(rows_mult_dataa_sel),
	.rows_mult_datab_sel(rows_mult_datab_sel),
	.ld_rows_mult_res_reg(ld_rows_mult_res_reg),
	
	.condition1_triggered(condition1_triggered),
	.condition2_triggered(condition2_triggered),
	
	.int_comparator_aeb(int_comparator_aeb),
	.int_comparator_alb(int_comparator_alb),
	.int_comparator_not_alb(int_comparator_not_alb),
	.j_index_comparator_alb(j_index_comparator_alb),
	.inner_Res_and_input_array(inner_Res_and_input_array),
	
	.current_state_test(current_state_test),
	.state_count_wire(state_count)
);

datapath #(
    .ROWS(ROWS)
) dp (
	.go_i(go_i),
	.clk(clk),
	.reset(reset),
	
	//.ROWS(ROWS),
	.NUMBER_OF_CONES(NUMBER_OF_CONES),
	
	.ld_int_add_sub_res_reg(ld_int_add_sub_res_reg),
	.ld_int_mult_res_reg(ld_int_mult_res_reg),
	
	.ld_rows_minus_one(ld_rows_minus_one),
	.ld_each_cone_size(ld_each_cone_size),
	.ld_each_cone(ld_each_cone),
	.ld_V_index(ld_V_index),
	.ld_temp_V_index(ld_temp_V_index),
	.ld_init_temp_V_index(ld_init_temp_V_index),
	.ld_Uinv_index(ld_Uinv_index),
	.ld_temp_Uinv_index(ld_temp_Uinv_index),
	.ld_Winv_index(ld_Winv_index),
	.ld_temp_Winv_index(ld_temp_Winv_index),
	.ld_init_temp_Winv_index(ld_init_temp_Winv_index),
	.ld_q_index(ld_q_index),
	.ld_s_index(ld_s_index),
	.ld_o_index(ld_o_index),
	.ld_last_diagonal(ld_last_diagonal),
	.ld_prime_diagonals(ld_prime_diagonals),
	.ld_q_summand(ld_q_summand),
	.ld_q_hat(ld_q_hat),
	.ld_q_trans(ld_q_trans),
	.ld_inner_Res(ld_inner_Res),
	.ld_v_inner(ld_v_inner),
	.ld_int_comparator_aeb_reg(ld_int_comparator_aeb_reg),
	.ld_total_point_count(ld_total_point_count),
	.ld_outer(ld_outer),
	.ld_result_point(ld_result_point),
	.ld_point_count(ld_point_count),
	.ld_i(ld_i),
	.ld_j(ld_j),
	.ld_divider_counter(ld_divider_counter),
	
	.clear_i(clear_i),
	.clear_j(clear_j),
	.clear_divider_counter(clear_divider_counter),
	
	.clear_point_count(clear_point_count),
	.clear_outer(clear_outer),
	.clear_inner_Res(clear_inner_Res),
	.clear_arrays(clear_arrays),
	
	.int_mult_dataa_sel(int_mult_dataa_sel),
	.int_mult_datab_sel(int_mult_datab_sel),
	.int_add_sub_dataa_sel(int_add_sub_dataa_sel),
	.int_add_sub_datab_sel(int_add_sub_datab_sel),
	.int_add_sub_add_sub_sel(int_add_sub_add_sub_sel),
	.int_comparator_dataa_sel(int_comparator_dataa_sel),
	.int_comparator_datab_sel(int_comparator_datab_sel),
	.int_comparator_dataa_i0_sel(int_comparator_dataa_i0_sel),
	.int_comparator_dataa_i1_sel(int_comparator_dataa_i1_sel),
	.int_comparator_datab_i0_sel(int_comparator_datab_i0_sel),
	.int_comparator_datab_i1_sel(int_comparator_datab_i1_sel),
	.int_comparator_datab_i3_sel(int_comparator_datab_i3_sel),
	.int_divider_numer_sel(int_divider_numer_sel),
	.int_divider_denom_sel(int_divider_denom_sel),
	.int_divider_clken(int_divider_clken),
	.inner_Res_sel(inner_Res_sel),
	.i_sel(i_sel),
	.v_inner_sel(v_inner_sel),
	
	.input_array_address_a_sel(input_array_address_a_sel),
	.input_array_address_b_sel(input_array_address_b_sel),
	.input_array_wren_a(input_array_wren_a),
	.input_array_wren_b(input_array_wren_b),
	
	.do_parallel_multiplication(do_parallel_multiplication),
	.clear_parallel_multiplication_results(clear_parallel_multiplication_results),
	.parallel_multiplication_second_operand_sel(parallel_multiplication_second_operand_sel),
	.q_array_address_sel(q_array_address_sel),
	.int_parallel_add_first_operand_sel(int_parallel_add_first_operand_sel),
	//.increment_temp_Winv_index(increment_temp_Winv_index),
	
	.ram_module_input_array_rst(ram_module_input_array_rst),
	.ram_module_input_array_en(ram_module_input_array_en),
	
	.clear_numerators(clear_numerators),
	.assign_numerators(assign_numerators),
	.numerator_sel(numerator_sel),
	.seq_loader_rst(seq_loader_rst),
	.ld_remain_to_inner_Res(ld_remain_to_inner_Res),
	
	.int_comparator_aeb(int_comparator_aeb),
	.int_comparator_alb(int_comparator_alb),
	.int_comparator_not_alb(int_comparator_not_alb),
	.j_index_comparator_alb(j_index_comparator_alb),
	.inner_Res_and_input_array(inner_Res_and_input_array),
	.ld_result_adjuster_to_inner_Res(ld_result_adjuster_to_inner_Res),
	.parallel_res_adj_rst(parallel_res_adj_rst),
	.parallel_res_adj_en(parallel_res_adj_en),
	
	.rows_mult_dataa_sel(rows_mult_dataa_sel),
	.rows_mult_datab_sel(rows_mult_datab_sel),
	.ld_rows_mult_res_reg(ld_rows_mult_res_reg),
	
	.condition1_triggered(condition1_triggered),
	.condition2_triggered(condition2_triggered),
	
	.result_point_i(result_point_i),
	.result_point_j(result_point_j),
	
	.fpga_total_point_count(fpga_total_point_count),
	.result_point_out(result_point_out)
);

parameter [6:0] SEGMENT_0 = 7'b1000000; // Digit 0
parameter [6:0] SEGMENT_1 = 7'b1111001; // Digit 1
parameter [6:0] SEGMENT_2 = 7'b0100100; // Digit 2
parameter [6:0] SEGMENT_3 = 7'b0110000; // Digit 3
parameter [6:0] SEGMENT_4 = 7'b0011001; // Digit 4
parameter [6:0] SEGMENT_5 = 7'b0010010; // Digit 5
parameter [6:0] SEGMENT_6 = 7'b0000010; // Digit 6
parameter [6:0] SEGMENT_7 = 7'b1111000; // Digit 7
parameter [6:0] SEGMENT_8 = 7'b0000000; // Digit 8
parameter [6:0] SEGMENT_9 = 7'b0010000; // Digit 9
parameter [6:0] SEGMENT_A = 7'b0001000; // Digit A
parameter [6:0] SEGMENT_B = 7'b0000011; // Digit B
parameter [6:0] SEGMENT_C = 7'b1000110; // Digit C
parameter [6:0] SEGMENT_D = 7'b0100001; // Digit D
parameter [6:0] SEGMENT_E = 7'b0000110; // Digit E
parameter [6:0] SEGMENT_F = 7'b0001110; // Digit F

reg [3:0] chunk_A, chunk_B, chunk_C, chunk_D, chunk_E, chunk_F, chunk_G, chunk_H;
reg [3:0] part_A, part_B, part_C, part_D, part_E, part_F, part_G, part_H, part_I, 
				part_J, part_K, part_L, part_M, part_N, part_O, part_P;
reg [6:0] hex_0, hex_1, hex_2, hex_3;

always @* begin
	 chunk_A = fpga_total_point_count[31:28];
	 chunk_B = fpga_total_point_count[27:24];
	 chunk_C = fpga_total_point_count[23:20];
	 chunk_D = fpga_total_point_count[19:16];
    chunk_E = fpga_total_point_count[15:12];
    chunk_F = fpga_total_point_count[11:8];
    chunk_G = fpga_total_point_count[7:4];
    chunk_H = fpga_total_point_count[3:0];
	 
	 part_A = state_count[63:60];
	 part_B = state_count[59:56];
	 part_C = state_count[55:52];
	 part_D = state_count[51:48];
	 part_E = state_count[47:44];
	 part_F = state_count[43:40];
	 part_G = state_count[39:36];
	 part_H = state_count[35:32];
	 part_I = state_count[31:28];
	 part_J = state_count[27:24];
	 part_K = state_count[23:20];
	 part_L = state_count[19:16];
	 part_M = state_count[15:12];
	 part_N = state_count[11:8];
	 part_O = state_count[7:4];
	 part_P = state_count[3:0];
	 
	 if (SW[5]) begin // current state
		hex_3 = 7'b1111111;
		hex_2 = 7'b1111111;
		hex_1 = get_segment({1'b0, current_state_test[6:4]});
		hex_0 = get_segment(current_state_test[3:0]);
	 end else if (SW[4]) begin // state count
		hex_3 = get_segment(part_A);
		hex_2 = get_segment(part_B);
		hex_1 = get_segment(part_C);
		hex_0 = get_segment(part_D);
	 end else if (SW[3]) begin
		hex_3 = get_segment(part_E);
		hex_2 = get_segment(part_F);
		hex_1 = get_segment(part_G);
		hex_0 = get_segment(part_H);
	 end else if (SW[2]) begin
		hex_3 = get_segment(part_I);
		hex_2 = get_segment(part_J);
		hex_1 = get_segment(part_K);
		hex_0 = get_segment(part_L);
	 end else if (SW[1]) begin
		hex_3 = get_segment(part_M);
		hex_2 = get_segment(part_N);
		hex_1 = get_segment(part_O);
		hex_0 = get_segment(part_P);
	 end else if (SW[0]) begin // point count
		hex_3 = get_segment(chunk_A);
		hex_2 = get_segment(chunk_B);
		hex_1 = get_segment(chunk_C);
		hex_0 = get_segment(chunk_D);
	 end else begin
		hex_3 = get_segment(chunk_E);
		hex_2 = get_segment(chunk_F);
		hex_1 = get_segment(chunk_G);
		hex_0 = get_segment(chunk_H);
	 end
end

assign HEX3 = hex_3;
assign HEX2 = hex_2;
assign HEX1 = hex_1;
assign HEX0 = hex_0;

/*reg [3:0] chunk_A, chunk_B;
always @* begin
	 chunk_A = addr_test[7:4];
    chunk_B = addr_test[3:0];
end*/

/*
assign HEX3 = get_segment(chunk_A);
assign HEX2 = get_segment(chunk_B);
assign HEX1 = get_segment(chunk_C);
assign HEX0 = get_segment(chunk_D);
*/


//assign HEX3 = get_segment(chunk_A);
//assign HEX2 = get_segment(chunk_B);

//assign HEX5 = get_segment(cs);
//assign HEX4 = get_segment(ns);

//assign HEX5 = get_segment(colors_used);

reg key0_prev; 
reg key1_prev; 


always @(posedge clk) begin
    key0_prev <= KEY[0];
    key1_prev <= KEY[1]; 

    // Reset addr_test if either KEY[2] or KEY[3] is pressed
    if (~KEY[2] || ~KEY[3]) begin
        result_point_i <= 10'b00000000000;
		  result_point_j <= 4'b0000;
    end else begin
        // Increment addr_test if KEY[0] is pressed
        if (~KEY[0] && key0_prev) begin
            result_point_i <= result_point_i + 1'b1;
				result_point_j <= 4'b0000;
        end

        // Decrement addr_test if KEY[1] is pressed
        if (~KEY[1] && key1_prev) begin
            result_point_j <= result_point_j + 1'b1; 
        end
    end
end

assign LEDG[7:0] = result_point_out;

function [6:0] get_segment(input [3:0] chunk);
    begin
        case(chunk)
            4'b0000: get_segment = SEGMENT_0;
            4'b0001: get_segment = SEGMENT_1;
            4'b0010: get_segment = SEGMENT_2;
            4'b0011: get_segment = SEGMENT_3;
            4'b0100: get_segment = SEGMENT_4;
            4'b0101: get_segment = SEGMENT_5;
            4'b0110: get_segment = SEGMENT_6;
            4'b0111: get_segment = SEGMENT_7;
            4'b1000: get_segment = SEGMENT_8;
            4'b1001: get_segment = SEGMENT_9;
            4'b1010: get_segment = SEGMENT_A;
            4'b1011: get_segment = SEGMENT_B;
            4'b1100: get_segment = SEGMENT_C;
            4'b1101: get_segment = SEGMENT_D;
            4'b1110: get_segment = SEGMENT_E;
            4'b1111: get_segment = SEGMENT_F;
            default: get_segment = 7'b1110111;
        endcase
    end
endfunction


endmodule
